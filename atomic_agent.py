import os
import json
from datetime import date
from dotenv import load_dotenv
import openai
import instructor
from pydantic import Field
from prompts import role, goal, instructions, knowledge

# Atomic Agents imports
from atomic_agents.agents.base_agent import BaseAgent, BaseAgentConfig
from atomic_agents.lib.base.base_io_schema import BaseIOSchema
from atomic_agents.lib.components.agent_memory import AgentMemory
from atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator
from atomic_agents.lib.base.base_tool import BaseTool

# Tavily client for web search
from tavily import TavilyClient

# Load environment variables and initialize Tavily client
load_dotenv()
tavily_api_key = os.getenv("TAVILY_API_KEY")
tavily_client = TavilyClient(api_key=tavily_api_key)

# Schemas with required docstrings
class OrchestratorInputSchema(BaseIOSchema):
    """Input schema for the Orchestrator Agent. Contains the user's message to be processed."""
    chat_message: str = Field(..., description="The user's input message to be analyzed and responded to.")

class OrchestratorOutputSchema(BaseIOSchema):
    """Combined output schema for the Orchestrator Agent. Contains the tool to use and its parameters."""
    tool: str = Field(..., description="The tool to use.")
    tool_parameters: dict = Field(default_factory=dict)

class FinalAnswerSchema(BaseIOSchema):
    """Schema for the final answer generated by the Orchestrator Agent.
    A response that addresses the user's query, giving high precedence to tool outputs.
    """
    final_answer: str = Field(..., description="A response that addresses the user's query, giving high precedence to tool outputs.")

class DateToolOutputSchema(BaseIOSchema):
    """Output schema for the date tool. A string representation of the date."""
    result: str = Field(..., description="Today's date as a well formatted string.")

class WebSearchToolInputSchema(BaseIOSchema):
    """Schema for the web search tool. Contains the query to use for the web search."""
    query: str = Field(..., description="The query to be used for the search.")

class WebSearchToolOutputSchema(BaseIOSchema):
    """Output Schema for the web search tool. A string containing the search results."""
    results: str = Field(..., description="The search results.")

class Agent:
    def __init__(self, model: str = "gpt-4o-mini"):
        """
        Initialize the Atomic Agents-based agent.
        """
        self.client = instructor.from_openai(
            openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        )
        self.system_prompt = SystemPromptGenerator(
            background=[role, goal, knowledge],
            steps=[
                "Understand the user's input and provide a relevant response.",
                "Respond to the user."
            ],
            output_instructions=[
                instructions,
                "***IMPORTANT***: When selecting a tool, make sure to adhere to the schema."
            ],
        )
        self.tools = self._create_tools()
        self.agent = self._create_orchestrator_agent(model)

    @staticmethod
    def date_tool() -> str:
        """
        Get the current date.
        """
        today = date.today().strftime("%B %d, %Y")
        return f"Today's date is: {today}"

    @staticmethod
    def web_search(query: str) -> str:
        """
        Search the web for the given query and return the results as a JSON string.
        """
        search_response = tavily_client.search(query)
        return json.dumps(search_response.get('results', []))

    def _create_tools(self) -> dict:
        """
        Create the tools for the agent.
        """
        agent = self

        class DateTool(BaseTool):
            """ Tool for looking up today's date.  Should be used to establish context."""
            input_schema = BaseIOSchema
            output_schema = DateToolOutputSchema

            def run(self, params=None):
                return DateToolOutputSchema(result=agent.date_tool())

        class WebSearchTool(BaseTool):
            """ Tool to perform web searches. Can be used to augment your knowledge."""
            input_schema = WebSearchToolInputSchema
            output_schema = WebSearchToolOutputSchema

            def run(self, params):
                results = agent.web_search(params.query)
                return WebSearchToolOutputSchema(results=results)

        return {"date": DateTool(), "web_search": WebSearchTool()}

    def _create_orchestrator_agent(self, model: str) -> BaseAgent:
        """
        Create the orchestrator agent.
        """
        config = BaseAgentConfig(
            client=self.client,
            model=model,
            system_prompt_generator=self.system_prompt,
            input_schema=OrchestratorInputSchema,
            output_schema=OrchestratorOutputSchema,
            memory=AgentMemory(max_messages=100),
        )
        return BaseAgent(config)

    def chat(self, message: str) -> str:
        """
        Process a chat message and return the agent's response.
        """
        try:
            input_schema = OrchestratorInputSchema(chat_message=message)
            tool_selection = self.agent.run(input_schema)

            if tool_selection.tool == "date":
                tool_output = self.tools["date"].run()
                self.agent.memory.add_message("system", tool_output)
            elif tool_selection.tool == "web_search":
                params = WebSearchToolInputSchema(
                    query=tool_selection.tool_parameters.get('query', message)
                )
                tool_output = self.tools["web_search"].run(params)
                self.agent.memory.add_message("system", tool_output)
            else:
                # Override unexpected tool selections
                tool_selection.tool = "none"
                no_tool = FinalAnswerSchema(final_answer="I can answer this questions without a tool.")
                self.agent.memory.add_message("system", no_tool)

            self.agent.output_schema = FinalAnswerSchema
            final_answer = self.agent.run(input_schema)
            self.agent.output_schema = OrchestratorOutputSchema

            return final_answer.final_answer

        except Exception as e:
            print(f"Error in chat: {e}")
            return "Sorry, I encountered an error processing your request."

    def clear_chat(self) -> bool:
        """
        Reset the conversation context.
        """
        try:
            self.agent.memory = AgentMemory(max_messages=100)
            return True
        except Exception as e:
            print(f"Error clearing chat: {e}")
            return False

def main() -> None:
    """
    Example usage demonstrating the agent interface.
    """
    agent = Agent()
    while True:
        query = input("You: ")
        if query.lower() in ['exit', 'quit']:
            break
        response = agent.chat(query)
        print(f"Assistant: {response}")

if __name__ == "__main__":
    main()
